"""
SMPLH model layer for HybrIK.
Generated by Gemini, modified by me. 2025/3/27
TODO:
1. needs a pytest script to test it.
"""

from __future__ import absolute_import, division, print_function

from collections import namedtuple
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import torch
import torch.nn as nn
from easydict import EasyDict as edict
from ..smplx.vertex_ids import vertex_ids

# Assuming lbs functions are in the same directory or properly imported
from .lbs import lbs, hybrik
from ..smplx.lbs import vertices2landmarks, mat2quat
from torch import Tensor

from typing import Literal
from jaxtyping import Float, Int, jaxtyped
import typeguard


# Define output structures
SMPLHOutput = namedtuple(
    'SMPLHOutput',
    [
        'vertices', 'joints', 'betas', 'global_orient',
        'body_pose', 'left_hand_pose', 'right_hand_pose',
        'transl', 'full_pose',
    ],
)
SMPLHOutput.__new__.__defaults__ = (None,) * len(SMPLHOutput._fields)

HybrIKOutput = edict # Use EasyDict for HybrIK output flexibility

NUM_POSE_JOINTS_IN_POSEDIRS = 51

class SMPLH_Layer(nn.Module):
    # SMPLH constants
    NUM_JOINTS = 52  # 22 body joints + 15 per hand = 52
    NUM_BODY_JOINTS = 22 # Including root
    NUM_HAND_JOINTS = 15
    NUM_POSE_PARAMS = (NUM_JOINTS - 1) * 3 # Axis-angle for 51 poseable joints
    NUM_BETAS = 10 # Or 16/300 depending on the model version

    # Joint names (example, adjust based on loaded model)
    JOINT_NAMES = [
        'pelvis', 'left_hip', 'right_hip',      # 2
        'spine1', 'left_knee', 'right_knee',    # 5
        'spine2', 'left_ankle', 'right_ankle',  # 8
        'spine3', 'left_foot', 'right_foot',    # 11
        'neck', 'left_collar', 'right_collar',  # 14
        'head',                                 # 15
        'left_shoulder', 'right_shoulder',      # 17
        'left_elbow', 'right_elbow',            # 19
        'left_wrist', 'right_wrist',            # 21
        # Left Hand
        'left_index1', 'left_index2', 'left_index3',        # 24
        'left_middle1', 'left_middle2', 'left_middle3',     # 27
        'left_pinky1', 'left_pinky2', 'left_pinky3',        # 30
        'left_ring1', 'left_ring2', 'left_ring3',           # 33
        'left_thumb1', 'left_thumb2', 'left_thumb3',        # 36
        # Right Hand
        'right_index1', 'right_index2', 'right_index3',     # 39
        'right_middle1', 'right_middle2', 'right_middle3',  # 42
        'right_pinky1', 'right_pinky2', 'right_pinky3',     # 45
        'right_ring1', 'right_ring2', 'right_ring3',        # 48
        'right_thumb1', 'right_thumb2', 'right_thumb3',     # 51
    ]

    # Vertex indices for fingertips (example, replace with actual indices)
    LEAF_VERTEX_IDS = {
        'LThumb': vertex_ids['smplh']['rthumb'], 'LIndex': vertex_ids['smplh']['rindex'], 'LMiddle': vertex_ids['smplh']['rmiddle'], 'LRing': vertex_ids['smplh']['rring'], 'LPinky': vertex_ids['smplh']['rpinky'],
        'RThumb': vertex_ids['smplh']['lthumb'], 'RIndex': vertex_ids['smplh']['lindex'], 'RMiddle': vertex_ids['smplh']['lmiddle'], 'RRing': vertex_ids['smplh']['lring'], 'RPinky': vertex_ids['smplh']['lpinky'],
    }


    @jaxtyped(typechecker=typeguard.typechecked)
    def __init__(
        self,
        model_path: str,
        gender: Literal['neutral', 'male', 'female'] = 'neutral',
        num_betas: int = 16,
        use_pose_blendshapes: bool = True, # Standard SMPLH has body pose blendshapes
        ext: str = 'npz', # Official SMPL/SMPLH models are often .npz
        dtype: torch.dtype = torch.float32,
        # Optional: Regressors for specific joint sets (e.g., COCO, MPII)
        # J_regressor_extra: Optional[str] = None,
        **kwargs,
    ) -> None:
        ''' SMPLH model layer constructor

        Parameters
        ----------
        model_path : str
            Path to the SMPLH model file (.npz or .pkl).
        gender : str, optional
            Gender ('neutral', 'male', 'female'). Default: 'neutral'.
        num_betas : int, optional
            Number of shape parameters. Default: 10.
        use_pose_blendshapes: bool, optional
            Whether to use pose blendshapes (typically for body only in SMPLH). Default: True.
        ext: str, optional
            Extension of the model file ('npz' or 'pkl'). Default: 'npz'.
        dtype : torch.dtype, optional
            Data type for tensors. Default: torch.float32.
        '''
        super(SMPLH_Layer, self).__init__()

        self.gender = gender
        self.num_betas = num_betas
        self.dtype = dtype
        self.use_pose_blendshapes = use_pose_blendshapes

        # Load model data
        if ext == 'npz':
            smpl_data = np.load(model_path, allow_pickle=True)
            # SMPLH npz structure might differ slightly, adjust keys as needed
            # Typically keys: 'v_template', 'shapedirs', 'posedirs', 'J_regressor',
            # 'kintree_table', 'weights', 'f'
            data_struct = {key: smpl_data[key] for key in smpl_data.files}
        elif ext == 'pkl':
            import pickle
            with open(model_path, 'rb') as f:
                smpl_data = pickle.load(f, encoding='latin1')
            # PKL structure might be nested (e.g., smpl_data['shapedirs'])
            # Adapt access based on the specific PKL format
            data_struct = smpl_data # Assuming flat dict or similar access
        else:
            raise ValueError(f"Unsupported model file extension: {ext}")

        # --- Register Buffers ---
        self.register_buffer(
            'faces_tensor',
            torch.tensor(data_struct['f'].astype(np.int64), dtype=torch.long),
        )

        # Vertices
        self.register_buffer(
            'v_template',
            torch.tensor(data_struct['v_template'], dtype=dtype),
        )

        # Shape Blendshapes (V x 3 x num_betas)
        # Ensure correct slicing if model provides more betas than requested
        shapedirs = data_struct['shapedirs'][:, :, :self.num_betas]
        self.register_buffer(
            'shapedirs',
            torch.tensor(shapedirs, dtype=dtype),
        )

        # Pose Blendshapes (V*3 x (num_body_joints*9))
        # SMPLH posedirs typically cover 21 body joints (excluding root, hands)
        if self.use_pose_blendshapes:
            # posedirs shape: (6890*3, 207) for SMPL -> (6890*3, 51*9=459) for SMPLH body.
            # Need to confirm the exact dimension from the model file.
            # Assuming it's (V*3, K*9) where K=51 for SMPLH body.
            posedirs_dim = NUM_POSE_JOINTS_IN_POSEDIRS * 9
            posedirs = data_struct['posedirs'].reshape(-1, posedirs_dim)[:, :posedirs_dim] # Slice if necessary
            # Transpose for matmul in lbs: (K*9, V*3)
            self.register_buffer(
                'posedirs',
                torch.tensor(posedirs.T, dtype=dtype),
            )
            self.num_body_joints_for_posedirs = NUM_POSE_JOINTS_IN_POSEDIRS
        else:
            # Register dummy posedirs if not used
            posedirs_dim = NUM_POSE_JOINTS_IN_POSEDIRS * 9
            self.register_buffer('posedirs', torch.zeros(posedirs_dim, self.v_template.shape[0]*3, dtype=dtype))
            self.num_body_joints_for_posedirs = 0


        # Joint Regressor (J x V), J=52 for SMPLH
        self.register_buffer(
            'J_regressor',
            torch.tensor(data_struct['J_regressor'].toarray() if hasattr(data_struct['J_regressor'], 'toarray') else data_struct['J_regressor'], dtype=dtype),
        )

        # Kinematic Tree (Parents for 52 joints)
        # kintree_table[0] usually contains parents for the base model (e.g., SMPL)
        # SMPLH parents need to be constructed or loaded if provided separately.
        # Assuming kintree_table provides the 52 joint parents.
        parents = data_struct['kintree_table'][0].astype(np.int64)
        parents[0] = -1 # Set root parent to -1
        self.register_buffer('parents', torch.tensor(parents, dtype=torch.long))
        assert len(parents) == self.NUM_JOINTS, f"Expected {self.NUM_JOINTS} parents, got {len(parents)}"

        # LBS Weights (V x J), J=52
        self.register_buffer(
            'lbs_weights',
            torch.tensor(data_struct['weights'], dtype=dtype),
        )

        # --- HybrIK specific setup ---
        # Define leaf indices and extended kinematic tree for HybrIK
        # These vertex indices depend heavily on the specific SMPLH model file used.
        # Using placeholders - **REPLACE THESE WITH ACTUAL INDICES**
        self.leaf_indices_hybrik = [
            self.LEAF_VERTEX_IDS['LThumb'], self.LEAF_VERTEX_IDS['LIndex'], self.LEAF_VERTEX_IDS['LMiddle'], self.LEAF_VERTEX_IDS['LRing'], self.LEAF_VERTEX_IDS['LPinky'],
            self.LEAF_VERTEX_IDS['RThumb'], self.LEAF_VERTEX_IDS['RIndex'], self.LEAF_VERTEX_IDS['RMiddle'], self.LEAF_VERTEX_IDS['RRing'], self.LEAF_VERTEX_IDS['RPinky'],
            # Add other potential leaves if needed (e.g., head top, feet tips)
            # Example: Head top (often around vertex 332 in SMPL)
            # Example: Big toes (often around 3216, 6617 in SMPL)
        ]
        self.num_leaf_joints_hybrik = len(self.leaf_indices_hybrik)

        extended_parents, children_map = self._extend_kinematic_tree_hybrik(self.parents, self.num_leaf_joints_hybrik)
        self.register_buffer('extended_parents_hybrik', extended_parents)
        self.children_map_hybrik = children_map # Store as dict

    def _extend_kinematic_tree_hybrik(self, base_parents: Tensor, num_leaves: int) -> Tuple[Tensor, Dict]:
        """ Creates the extended kinematic tree and children map for HybrIK """
        extended_parents_list = list(base_parents.cpu().numpy())
        num_base_joints = len(extended_parents_list)

        # Define parents for the leaf joints (vertices)
        # These should correspond to the last joint in each finger/toe chain etc.
        # Example: Fingertips parented by finger joint 3, head top by head joint etc.
        # **THIS REQUIRES KNOWLEDGE OF THE SMPLH KINEMATIC TREE**
        # Placeholder parent indices - **REPLACE WITH ACTUAL PARENT INDICES**
        # Left Hand Leaves (Thumb3, Index3, Middle3, Ring3, Pinky3 -> indices 36, 24, 27, 33, 30)
        leaf_parents_indices = [
            36, 24, 27, 33, 30,
            # Right Hand Leaves (Thumb3, Index3, Middle3, Ring3, Pinky3 -> indices 51, 39, 42, 48, 45)
            51, 39, 42, 48, 45,
        ]
        # Add parents for other leaves if included (head, toes)

        assert len(leaf_parents_indices) == num_leaves, "Mismatch between num_leaves and defined parents"
        extended_parents_list.extend(leaf_parents_indices)
        extended_parents_tensor = torch.tensor(extended_parents_list, dtype=torch.long)

        # Create children map for the extended tree
        num_extended_joints = len(extended_parents_tensor)
        children_map = {i: -1 for i in range(num_extended_joints)} # -1: leaf, >0: single child, <-1: multiple children

        for i in range(1, num_extended_joints):
            parent_idx = extended_parents_tensor[i].item()
            if parent_idx == -1: continue # Should only be root

            current_child_val = children_map.get(parent_idx, -1)
            if current_child_val == -1: # First child
                children_map[parent_idx] = i
            elif current_child_val > 0: # Second child -> multiple
                children_map[parent_idx] = -2
            else: # Already multiple children
                children_map[parent_idx] -= 1

        return extended_parents_tensor, children_map


    @jaxtyped(typechecker=typeguard.typechecked)
    def forward(
        self,
        betas: Optional[Float[Tensor, "batch num_betas"]] = None,
        global_orient: Optional[Float[Tensor, "batch 1 3 3"]] = None,
        body_pose: Optional[Float[Tensor, "batch 21 3 3"]] = None, # Pose for 21 body joints
        left_hand_pose: Optional[Float[Tensor, "batch 15 3 3"]] = None,
        right_hand_pose: Optional[Float[Tensor, "batch 15 3 3"]] = None,
        transl: Optional[Float[Tensor, "batch 3"]] = None,
        return_verts: bool = True,
        return_full_pose: bool = False,
        **kwargs,
    ) -> SMPLHOutput:
        ''' Forward pass for the SMPLH model using standard LBS.

            Parameters
            ----------
            betas: Shape parameters, BxN_b (N_b = 10 or 16)
            global_orient: Global rotation, Bx1x3x3
            body_pose: Body joint rotations (excluding root), Bx21x3x3
            left_hand_pose: Left hand joint rotations, Bx15x3x3
            right_hand_pose: Right hand joint rotations, Bx15x3x3
            transl: Global translation, Bx3
            return_verts: Whether to return vertices.
            return_full_pose: Whether to return the concatenated full pose.

            Returns
            -------
            SMPLHOutput: Named tuple containing vertices, joints, etc.
        '''
        device, dtype = self.shapedirs.device, self.dtype # Use layer's dtype

        # Get batch size from inputs
        batch_size = 1
        input_vars = [betas, global_orient, body_pose, left_hand_pose, right_hand_pose, transl]
        for var in input_vars:
            if var is not None:
                batch_size = max(batch_size, var.shape[0])

        # Use default tensors if inputs are None
        if betas is None:
            betas = torch.zeros([batch_size, self.num_betas], dtype=dtype, device=device)
        if global_orient is None:
            global_orient = torch.eye(3, dtype=dtype, device=device).view(1, 1, 3, 3).expand(batch_size, -1, -1, -1)
        if body_pose is None:
            body_pose = torch.eye(3, dtype=dtype, device=device).view(1, 1, 3, 3).expand(batch_size, self.NUM_BODY_JOINTS - 1, -1, -1)
        if left_hand_pose is None:
            left_hand_pose = torch.eye(3, dtype=dtype, device=device).view(1, 1, 3, 3).expand(batch_size, self.NUM_HAND_JOINTS, -1, -1)
        if right_hand_pose is None:
            right_hand_pose = torch.eye(3, dtype=dtype, device=device).view(1, 1, 3, 3).expand(batch_size, self.NUM_HAND_JOINTS, -1, -1)
        if transl is None:
            transl = torch.zeros([batch_size, 3], dtype=dtype, device=device)

        # Ensure correct shapes
        body_pose = body_pose.reshape(batch_size, self.NUM_BODY_JOINTS - 1, 3, 3)
        left_hand_pose = left_hand_pose.reshape(batch_size, self.NUM_HAND_JOINTS, 3, 3)
        right_hand_pose = right_hand_pose.reshape(batch_size, self.NUM_HAND_JOINTS, 3, 3)
        global_orient = global_orient.reshape(batch_size, 1, 3, 3)

        # Concatenate poses into Bx52x3x3
        full_pose = torch.cat(
            [global_orient, body_pose, left_hand_pose, right_hand_pose], dim=1,
        )

        # Expand v_template to batch size if needed
        v_template_batch = self.v_template.unsqueeze(0).expand(batch_size, -1, -1)

        # Call LBS
        vertices, joints = lbs(
            betas=betas,
            pose=full_pose,
            v_template=v_template_batch,
            shapedirs=self.shapedirs,
            posedirs=self.posedirs if self.use_pose_blendshapes else None, # Pass None if not used
            J_regressor=self.J_regressor,
            parents=self.parents,
            lbs_weights=self.lbs_weights,
            pose2rot=False, # Input pose is already rotmats
            num_body_joints=self.num_body_joints_for_posedirs, # Pass how many joints posedirs covers
        )

        # Apply translation
        root_offset = joints[..., 0, :]
        transl = transl - root_offset
        joints = joints + transl.unsqueeze(dim=-2)
        vertices = vertices + transl.unsqueeze(dim=-2)

        # Optional: Calculate landmarks if regressor provided
        # landmarks = vertices2landmarks(vertices, self.faces_tensor, ...)
        # joints = torch.cat([joints, landmarks], dim=1) # Append landmarks

        output = SMPLHOutput(
            vertices=vertices if return_verts else None,
            joints=joints,
            betas=betas,
            global_orient=global_orient,
            body_pose=body_pose,
            left_hand_pose=left_hand_pose,
            right_hand_pose=right_hand_pose,
            transl=transl,
            full_pose=full_pose if return_full_pose else None,
        )
        return output

    @jaxtyped(typechecker=typeguard.typechecked)
    def hybrik(
        self,
        betas: Optional[Float[Tensor, "batch num_betas"]] = None,
        pose_skeleton: Optional[Float[Tensor, "batch K 3"]] = None, # K = 52 + num_leaves
        phis: Optional[Float[Tensor, "batch 51 2"]] = None, # Twist for 51 poseable joints
        transl: Optional[Float[Tensor, "batch 3"]] = None,
        return_verts: bool = True,
        root_align: bool = True, # Align output to root joint if transl is None
        naive_ik: bool = False, # Use naive IK version?
        use_svd_ik: bool = True, # Use SVD for multi-child joints in IK?
        **kwargs,
    ) -> HybrIKOutput:
        ''' Inverse Kinematics pass for SMPLH using HybrIK method.

            Parameters
            ----------
            betas: Shape parameters, BxN_b
            pose_skeleton: Target skeleton joint locations, Bx52x3
            phis: Twist parameters [cos(phi), sin(phi)], Bx51x2
            transl: Global translation, Bx3
            return_verts: Whether to return vertices.
            root_align: If transl is None, subtract root joint position.
            naive_ik: Use the simpler sequential IK solver.
            use_svd_ik: Use SVD for multi-child joints (pelvis, shoulders etc.) in IK.

            Returns
            -------
            HybrIKOutput: edict containing vertices, joints, rot_mats, etc.
        '''
        device, dtype = self.shapedirs.device, self.dtype

        # Get batch size
        batch_size = 1
        if betas is not None: batch_size = max(batch_size, betas.shape[0])
        if pose_skeleton is not None: batch_size = max(batch_size, pose_skeleton.shape[0])
        if phis is not None: batch_size = max(batch_size, phis.shape[0])

        # Use default tensors if inputs are None
        if betas is None:
            betas = torch.zeros([batch_size, self.num_betas], dtype=dtype, device=device)
        if pose_skeleton is None:
            # Cannot run HybrIK without target skeleton
            raise ValueError("pose_skeleton is required for hybrik method")
        if phis is None:
            # Default to zero twist
            phis = torch.zeros([batch_size, self.NUM_JOINTS - 1, 2], dtype=dtype, device=device)
            phis[:, :, 0] = 1.0 # cos(0) = 1

        # Check pose_skeleton dimension
        expected_skel_joints = self.NUM_JOINTS + self.num_leaf_joints_hybrik
        if pose_skeleton.shape[1] != expected_skel_joints:
             raise ValueError(f"Expected pose_skeleton with {expected_skel_joints} joints, got {pose_skeleton.shape[1]}")
        if phis.shape[1] != self.NUM_JOINTS - 1:
             raise ValueError(f"Expected phis with {self.NUM_JOINTS - 1} entries, got {phis.shape[1]}")

        # Expand v_template to batch size if needed
        v_template_batch = self.v_template.unsqueeze(0).expand(batch_size, -1, -1)

        # Call HybrIK function from lbs.py
        vertices, joints, rot_mats = hybrik(
            betas=betas,
            pose_skeleton=pose_skeleton,
            phis=phis,
            v_template=v_template_batch,
            shapedirs=self.shapedirs,
            posedirs=self.posedirs if self.use_pose_blendshapes else None,
            J_regressor=self.J_regressor,
            parents=self.extended_parents_hybrik, # Use extended tree for IK
            children=self.children_map_hybrik,    # Use extended map for IK
            lbs_weights=self.lbs_weights,
            leaf_indices=self.leaf_indices_hybrik,
            num_body_joints_pose=self.num_body_joints_for_posedirs,
            num_total_joints=self.NUM_JOINTS, # Base SMPLH joints
            train=self.training, # Pass training status
            naive=naive_ik,
            use_svd=use_svd_ik,
        )

        # Handle translation or root alignment
        if transl is not None:
            root_offset = joints[..., 0, :]
            transl = transl - root_offset
            joints = joints + transl.unsqueeze(dim=1)
            vertices = vertices + transl.unsqueeze(dim=1)
        elif root_align:
            root_j = joints[:, [0], :].clone() # Pelvis is joint 0
            joints = joints - root_j
            vertices = vertices - root_j

        # Convert rotations to quaternion if needed
        theta_quat = mat2quat(rot_mats.reshape(-1, 3, 3)).reshape(batch_size, self.NUM_JOINTS, 4)

        output = HybrIKOutput(
            vertices=vertices if return_verts else None,
            joints=joints, # SMPLH 52 joints
            rot_mats=rot_mats, # SMPLH 52 rotations
            theta_quat=theta_quat, # SMPLH 52 quaternions (w,x,y,z)
            betas=betas,
            transl=transl if transl is not None else (-root_j.squeeze(1) if root_align else None),
        )
        return output

    @jaxtyped(typechecker=typeguard.typechecked)
    def forward_simple(
        self,
        betas: Optional[Float[Tensor, "batch num_betas"]] = None,
        full_pose: Optional[Float[Tensor, "batch 52 3 3"]] = None,
        transl: Optional[Float[Tensor, "batch 3"]] = None,
        return_verts: bool = True,
        root_align: bool = True,
        **kwargs,
    ) -> edict:
        """ Simplified forward pass taking full pose matrix directly. """
        device, dtype = self.shapedirs.device, self.dtype

        batch_size = 1
        if betas is not None: batch_size = max(batch_size, betas.shape[0])
        if full_pose is not None: batch_size = max(batch_size, full_pose.shape[0])

        if betas is None:
            betas = torch.zeros([batch_size, self.num_betas], dtype=dtype, device=device)
        if full_pose is None:
            full_pose = torch.eye(3, dtype=dtype, device=device).view(1, 1, 3, 3).expand(batch_size, self.NUM_JOINTS, -1, -1)
        if transl is None and not root_align:
            transl = torch.zeros([batch_size, 3], dtype=dtype, device=device)

        v_template_batch = self.v_template.unsqueeze(0).expand(batch_size, -1, -1)

        vertices, joints = lbs(
            betas=betas,
            pose=full_pose,
            v_template=v_template_batch,
            shapedirs=self.shapedirs,
            posedirs=self.posedirs if self.use_pose_blendshapes else None,
            J_regressor=self.J_regressor,
            parents=self.parents,
            lbs_weights=self.lbs_weights,
            pose2rot=False,
            num_body_joints=self.num_body_joints_for_posedirs,
        )

        root_j = None
        if transl is not None:
            root_offset = joints[..., 0, :]
            transl = transl - root_offset
            joints = joints + transl.unsqueeze(dim=1)
            vertices = vertices + transl.unsqueeze(dim=1)
        elif root_align:
            root_j = joints[:, [0], :].clone()
            joints = joints - root_j
            vertices = vertices - root_j

        output = edict(
            vertices=vertices if return_verts else None,
            joints=joints,
            betas=betas,
            full_pose=full_pose,
            transl=transl if transl is not None else (-root_j.squeeze(1) if root_align else None),
        )
        return output

    def get_extended_joints(self, joints, vertices):
        leaf_joints = vertices[:, self.LEAF_VERTEX_IDS]
        return torch.cat([joints, leaf_joints], dim=1)
